变量，作用域与内存
1. 变量
当把一个值赋给变量的时候， js引擎会首先确认这个值是原始值还是引用值。
+ 原始值就是按值来访问的，操作的就是存储在变量中的实际值
+ 引用值是保存在内存中的对象。 js是不允许直接访问内存位置的，所以不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用，而非实际的对象本身，所以保存引用值的变量都是按引用来访问的
除了存储方式的不同，复制变量的时候也存在很大的差异。
+ 原始值复制的是这个变量的副本，也就是两个值是相互独立的，互不影响。
+ 引用值复制的只是这个值的引用，也就是一个指向存储在堆内存中的对象的一个指针。两个变量实际上指向同一个对象，一个变量修改会影响到另一个变量

传递参数
ECMAScript中所有函数的参数其实都是按值传递的，很多开发者错误的认为，当在函数内部修改引用值而变化反映到函数外部的时候，就以为参数是按引用传递的，为了证明对象是按值来进行传递的，看下面的一个例子
```
function fn(obj){
  obj.name = 'a'
  obj = new Object()
  obj.name = 'b'
}

let person = {}
fn(person)
console.log(person.name)  // a
```
函数内部obj被设置为一个新对象并复制name为'b'，如果person是按引用传递的，那么person应该自动将指针指向name为'b'的对象。可是当我们访问person.name的时候值为'a'，这表明函数内部参数的值改变之后，原始的引用仍然没变。当obj在函数内部被重写时。它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了

2. 上下文与作用域
每个上下文都有一个关联的变量对象，在这个上下文中定义的所有对象和函数都会存在于这个对象上，上下文在其所有代码被执行完毕后会被销毁（全局上下文在应用退出前才会被销毁）。变量对象无法通过代码访问
上下文中的代码在执行的时候会创建变量对象的一个作用域链，代码正在执行的上下文的变量对象始终位于作用域链的最前端。全局上下文的变量对象始终是作用域链的最后一个变量对象
内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。

3. 变量声明
使用var声明变量时，变量会被自动添加到最接近的上下文。如果变量未声明就初始化了，那么就会被自动添加到全局上下文

+ var声明会被拿到函数作用域或者全局作用域的最顶部。这个现象叫做变量提升。变量提升可以让变量声明前使用变量而不报错
+ let关键字和var是类似的，只是let是块级作用域，块级作用域是由最近的{}来界定的。比如if块，while块，function块
```
for(var i = 0; i < 10; ++i) {}
console.log(i)
for(let j = 0; j < 10; ++j) {}
console.log(j) // j is not defined
```
严格来讲， let在js运行的时候也会被提升，但由于‘暂时性死区’的原因，实际上不能声明之前使用let变量，因此let提升跟var是不一样的。
+ const声明的变量必须同时初始化为某个值，一旦声明就不能再重新赋值。其他方面与let是一样的。赋值为对象的const变量不能再被重新赋值为其他的引用值，但对象的key是不受限制的
```
const obj = {}
obj = {}  // Assignment to constant variable.
obj.name = 'lisa'
console.log(obj) // {name: 'lisa'}
```
